# PipeRT

Real-Time meets High-Delay: A hybrid scheduling and dataflow framework for DSP applications

## Features

 - High performance
   - Multithreaded scheduler with worker pool
   - In-place running in memory, allocations are only made in the setup phase, not in the running phase
   - Uses mostly non-blocking algorithms avoiding OS locks
 - Easy to use
   - No need for user to have own mutexes or any kind of synchronization primitives
   - Nice, compact OOP API with templates to support own data types
   - Cross-platform C++11 code tested on gcc and clang
 - Versatile
   - Configurable buffers to support low- and high delay units
   - Supports stateless and stateful (accumulate) tasks
   - Supports user controlled threads besides own thread pool to support UI, I/O or special thread affinity
   - Supports circles (feedback) in the pipeline chain
   - Supports multiple entry and exit (even reentry) points for distributed workflows
 - Measurable (coming soon)
   - Supports measurement-driven development via its own, minimal impact autoprofiling system
   - Has a measurement API which exposes autoprofiling capabilities of the whole pipeline
   - Pluggable measurements: The user can fit any logging mechanism to the profiler

## Normal Build for Your Project

You need the following packages installed on your system to build the library:
 - `git` for downloading this repo
 - `cmake` and `ninja-build` for running the build
 - `gcc`, `g++` for compiling with GCC _OR_
 - `clang`, `clang++` and `llvm` for compiling with Clang

Optional:
 - `doxygen` will generate HTML documentation for you

Steps to build:
 1. Download this repo
 2. Run `./build.sh`
 3. What you need for your project:
   - `include` folder
   - `build/libpipert.so` dynamic library _OR_
   - `build/libpipert_static.a` static library
 4. Find the documentation under `build/docs/index.html`

## Development Build for Contributors

Besides everything under _Normal Build_, you can optionally have the following packages:
 - `clang-format` is used to keep our coding conventions
 - `gcovr` will generate you text and HTML coverage reports

Steps for development build:
 1. Checkout the repo
 2. Run `./devbuild.sh` or choose a generator for your IDE by using `./devbuild.sh -G "<yourIDE> - Ninja"` (see `cmake -h`)
 3. Find a debug build under `build_debug` and a release build under `build_release` folders
 4. In any of these, open your generated IDE project or use `ninja` and `ninja test` targets from command line
 5. Coverage report will only be generated for the debug build into `build_debug/coverage.html` and can be regenerated by issuing `ninja coverage` command
 6. Documentation will only be generated for the release build by default into `build_release/docs/index.html`, but generation can be forced by using `ninja docs` command

Have fun!
